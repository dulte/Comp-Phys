\documentclass[a4paper, 10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{a4wide}
\usepackage{color}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[dvips]{epsfig}
\usepackage[toc,page]{appendix}
\usepackage[T1]{fontenc}
\usepackage{cite} % [2,3,4] --> [2--4]
\usepackage{shadow}
\usepackage{hyperref}
\usepackage{titling}
\usepackage{marvosym }

\setlength{\droptitle}{-10em}   % This is your set screw

\setcounter{tocdepth}{2}

\lstset{language=c++}
\lstset{alsolanguage=[90]Fortran}
\lstset{basicstyle=\small}
\lstset{backgroundcolor=\color{white}}
\lstset{frame=single}
\lstset{stringstyle=\ttfamily}
\lstset{keywordstyle=\color{red}\bfseries}
\lstset{commentstyle=\itshape\color{blue}}
\lstset{showspaces=false}
\lstset{showstringspaces=false}
\lstset{showtabs=false}
\lstset{breaklines}
\title{FYS3150 - Project 3}
\author{Daniel Heinesen, Gunnar Lange}
\begin{document}
\maketitle
\begin{abstract}
We present numerical models of our solar system with varying levels of complexity.
\end{abstract}

\tableofcontents
\newpage
\section{Introduction}
The n-body problem is a recurring theme in many physics publications (see for example \textbf{HERE}), due to its wide applicability in many different fields, such as \textbf{REFEREENCE}.  Analytic solutions of these problems are notoriously hard to come by and are, in most situations, unattainable. Therefore, these problems are almost always solved by use of numerical techniques. We present two different numerical methods for solving the ODE's resulting from Newton's gravitational laws - Euler's method and the velocity-Verlet method. We investigate the stability of both methods for varying complexity of the system.
\section{Theoretical model}\label{Theoretical_section}
In this section, we introduce the quantities and equations required to model the solar system. We begin by introducing the relevant equations, and subsequently discuss how to solve these numerically. We continue with a brief discussion of the units used, followed by a discussion of tests that we can implement to test our numerical results. We conclude with a brief diversion to relativistic effects in the solar system.
\subsection{Newtonian Gravity}\label{Newtonian_Gravity}
Newton's general law of gravitation, which describes the force of gravity between two objects, is given by:
\begin{equation}
\vec{F}_{G}=\frac{Gm_1m_2}{r^3}\vec{r}
\end{equation}
Here $F_G$ is the force of gravity on the first mass, $G$ is the universal gravitational constant, $m_i$ are the masses of the two objects, and $\vec{r}$ is the vector pointing from $m_1$ to $m_2$. This law can be combined with Newton's second law of motion, to give a set of coupled differential equations:
\begin{equation}\label{eq:coupled_diff}
\begin{split}
\frac{d^2x}{dt^2}=\frac{F_{G,x}}{m_1}\\
\frac{d^2 y}{dt^2}=\frac{F_{G,y}}{m_1}\\
\frac{d^2 z}{dt^2}=\frac{F_{G,z}}{m_1}\\
\end{split}
\end{equation}
Where $F_{G,x}, F_{G,y}$ and $F_{G,z}$ are the components of the gravitational force in the $x, y$ and $z$ directions respectively. These equations can be reduced to a set of first-order equations by introducing the velocity components, $v$, such that:
\begin{equation}\label{eq:Velocity_position_equation}
\frac{dx}{dt}=v_x, \quad \quad \frac{dv_x}{dt}=\frac{F_{G,x}}{m_1}=a_x(x,y,z)
\end{equation}
And equivalently for the $y$ and $z$ direction. This gives six coupled, first-order, linear, differential equations.
\subsection{Implementing the initial conditions}\label{implement_IC}
To find a unique solution of the set of equations in section \ref{Newtonian_Gravity}, we require some initial conditions, i.e. some $x(t=0)$, $v_x(t=0)$, and equivalently for the $y$ and $z$ direction. For our first model (described in section \ref{First_model}) we will, for simplicity, let the earth be $1$ AU away from the sun, with an initial velocity that ensures a circular orbit. We show in appendix \ref{ap:Find_Circular_orbit} that this results in the requirement that the initial velocity be given by:
\begin{equation}
v_0=\sqrt{\frac{GM_{\odot}}{r}}
\end{equation}
Where $M_{\odot}$ is the mass of the sun and $r$ is the distance to the sun.\\
\linebreak
For the subsequent models, with multiple planets, we will use the initial positions and velocity provided on NASA's \href{http://ssd.jpl.nasa.gov/horizons.cgi#top}{webpages}\footnote{http://ssd.jpl.nasa.gov/horizons.cgi\#top}, letting $t=0$ correspond to \textbf{INSERT SOMETHNG HERE}.\\
\linebreak
We want to ensure that the center of mass of our solar system is stable at the origin. On NASA's webpage, we can choose the coordinate origin, however, it is not entirely clear if the velocities have been adjusted so that the center of mass is at rest. Therefore we adjusted the position and velocity of the sun to accommodate this. The position vector of the center of mass, $\vec{R}_{COM}$, is found from:
$$\vec{R}_{COM}=\sum_i m_i\vec{r}_i$$
The sum is over all bodies. $\vec{r}_i$ is the position vector of body $i$,  and $m_i$ is its mass. As the sun is by far the heaviest mass in the system, we can ensure that $\vec{R}=\vec{0}$ by letting the position vector of the sun, $\vec{r}_{\odot}$ be given by:
$$\vec{r}_{\odot}=-\frac{\sum_j m_j\vec{r}_j}{M_{\odot}}$$
Where the sum is over all bodies \textit{except the sun}. We can do the same thing for the velocity of the center of mass, $\vec{V}_{COM}$, which is given by:
$$\vec{V}_{COM}=\sum_i m_i \vec{v}_i$$
Where $\vec{v}_i$ is the velocity of body $i$. We can then let the velocity of the sun, $\vec{v}_{\odot}$ be:
$$\vec{v}_{\odot}=-\frac{\sum_j m_j\vec{v}_j}{M_{\odot}}$$
Where the sum is again over all bodies \textit{except} the sun. This ensure that the center of mass of our system is fixed at the origin.
\subsection{Discretizing the equations}\label{discretize_equations}
We will solve the equations in \ref{eq:coupled_diff} numerically. Therefore we require discretized versions of the these equations. We want to simulate from $t=t_0$ to $t=t_f$, and choose $N$ evenly spaced points in this interval. This gives us a timestep, $h$, of:
$$h=\frac{t_f-t_0}{N}$$
Let now $t_i=a+ih$, where $i$ goes from $0$ to $N$. Furthermore, let $x_i=x(t_i)$ and $ v_{x,i}=v_x(t_i)$, and equivalently for the $y$ and $z$ direction. Finally, discretize the acceleration as $a_{x,i}=a_x(x_i, y_i, z_i)$. This allows us to discretize the derivatives in equation \ref{eq:Velocity_position_equation}. We will do this in two separate ways; with the forward Euler algorithm and with the Velocity-Verlet algorithm.
\subsubsection{Euler's forward method}
Euler's forward algorithm amounts to discretizing the derivatives from section \ref{Newtonian_Gravity} as:
\begin{equation}\label{eq:Euler_Forward}
\frac{dg}{dt}\approx \frac{g_{i+1}-g_i}{h}
\end{equation}
This approximation is based on Taylor-expanding the function $g(t)$ to the second order, as explained \textbf{HERE}. Inserting this approximation for the derivatives in equation \ref{eq:Euler_Forward}, and rearranging some of the terms, gives:
\begin{equation}
\begin{split}
v_{x, i+1}=v_{x,i}+ha_{x,i}\\
x_{i+1}=x_i+hv_{x,i}
\end{split}
\end{equation}
And again equivalently for the $x$ and $y$ direction. This is the Euler forward algorithm. Combining this with the initial conditions, $\vec{v}(t_0)=\vec{v}_0$ and $\vec{x}(t_0)=\vec{x}_0$, makes it possible to solve the equations of Newtonian gravity. Closer inspection (through Taylor expansion, such as found \textbf{HERE} \href{http://www.math.unl.edu/~gledder1/Math447/EulerError}{here}), reveals that the local error is proportional to $h^2$, whereas the global error is proportional to $h$. Thus, whilst this is a straightforward algorithm, the errors quickly accumulate. It is therefore of interest to investigate a slightly improved algorithm:

\subsubsection{Velocity-Verlet Algorithm}
The Velocity-Verlet algorithm is based on the idea of Taylor-expanding the acceleration, in addition to the velocity and position. The details can be found in appendix \ref{ap:Deriving_VelVer}, but the method produces the following equations:
\begin{equation} \label{eq:Vel_Ver_eq}
\begin{split}
x_{i+1}=x_i+hv_{x,i}+\frac{h^2}{2}a_{x,i}\\
v_{x,i+1}=v_{x,i}+\frac{h}{2}\left(a_{x,i+1}+a_{x,i}\right)
\end{split}
\end{equation}
And similarly for the $x$ and the $y$ equations. Note that $a_{i+1}$ depends on $x_i, y_i$ and $z_i$, and therefore all three position coordinates must be computed before we can compute the velocity. As shown in our analysis in the \textbf{APPENDIX}, the local error is proportional to $h^3$, and in turn the global error is proportional to $h^2$, as shown \textbf{HERE}.\\
\linebreak
Notice that $a_{x i+1}$ can be reused in the next step, so this method does not incur any additional calls to the acceleration function in the main loop, as compared to the Forward Euler algorithm. The method only costs a few more FLOPs;
\begin{itemize}
\item We must perform two additional multiplications for each dimension, specifically $(h^2/2)\cdot a_{x,i}$ and $(h/2)\cdot a_{x, i+1}$
\item We must perform two further additions per dimension, namely adding $(h^2/2)a_{x,i}$ and $(h/2)a_{x, i+1}$ to respectively $x_{i+1}$ and $v_{x, i+1}$.
\end{itemize} 
This gives four additional FLOPs per timestep and dimension, i.e. 12 FLOPs per timestep. Thus if we have $N$ points in the main-loop, this gives an additional $12N$ FLOPs. Note that $h^2/2$ and $h/2$ can be precomputed, and therefore do not contribute to the number of FLOPs in the main loop. 
\subsection{Choice of units}
As we will be modelling our solar system, a natural unit of length is the average distance between the earth and the sun, the astronomical unit, AU. In SI-units, $1 \mathrm{AU} \approx 1.496 \cdot 10^{11} \mathrm{m}$. As the most massive object in the solar system is the sun, we choose one solar mass, $M_{\odot}$ as our mass unit. In SI units, $M_{\odot} \approx 1.99 \cdot 10^{30}$. We will use the mean tropical year, which is about 365.24 days of 864000 seconds\textbf{REFERENCE HERE}. This choice of units has one considerable advantage - it simplifies the expression for the gravitational constant, $G$. As shown in appendix \ref{ap:Find_Circular_orbit}, with this choice of units the gravitational constant becomes:
$$G=4\pi^2 \ \mathrm{AU^{3}yr^{-2}M_{\odot}^{-1}}$$
As discussed in section \ref{GR_section}, we will also use the speed of light. With our units, this is given by:
$$c=63\ 198 \ \mathrm{AU/yr}$$
\subsection{Conserved quantities in the system}\label{conservation_of_energy}
To check the consistency of our results, we will investigate whether certain quantities, which we expect to be conserved, are indeed conserved.
\subsubsection{Conservation of mechanical energy}
As there are no external forces in the system, we expect the mechanical energy to be conserved. There are two kinds of energy to consider in our system: kinetic and potential energy. The kinetic energy of a single body is simply given by:
$$E_{k}=\frac{1}{2}mv^2$$
Where $m$ is the mass of our celestial body and $v$ is the absolute value of its velocity. This is the standard formula for the kinetic energy. The potential energy can be found by integrating the force, choosing infinity as a reference point, i.e. $U(\infty)=0$:
$$U=-\int_r^{\infty} \frac{GMm}{r'^2} dr'=-\frac{GMm}{r}$$
This is the potential energy between the bodies. Thus the total energy (which should be conserved) is given by:
\begin{equation}\label{eq:total_energy}
E_{tot}=\sum_{i} \frac{1}{2}m_iv_i^2 - \sum_{i<j}\sum_{j}\frac{Gm_im_j}{r_{ij}}
\end{equation}
Where $i$ runs over all the bodies and $r_{ij}$ is the norm of the distance between body $i$ and $j$. Note that the second sum of the potential energy only goes to $i<j$, to avoid double-counting the energy.
\subsubsection{Conservation of angular momentum per unit mass}
As there is no external force, there is also no external torque. Therefore, the net angular momentum per unit mass should be conserved in our system. The angular momentum per unit mass of a body is generally given by:
$$\vec{l}=\vec{r}\times \vec{v}$$
Where $\vec{v}$ is the velocity of the body, and $\vec{r}$ is the distance to the center of mass. The total angular momentum per mass is then is then:
\begin{equation}\label{eq:total_angular_momentum}
\vec{l}_{tot}=\sum_i \vec{r}_i\times \vec{v}_i
\end{equation}
Where the sum is over all bodies.\\
\linebreak
Equations \ref{eq:total_energy} and \ref{eq:total_angular_momentum} both describe quantities which should be conserved. Thus, an important consistency check for our code, is to test if these quantities are indeed (approximately) constant throughout our simulation.
\subsection{Escape velocity}\label{escape_vel_section}
Another way we can check the consistency of our results is to investigate the escape velocities of the planets. This can be done by equating the potential energy to the kinetic energy. This is a difficult problem for a many-body problem. Therefore, we will only implement this in  the two-body case, with the sun and the earth. Equating potential and kinetic energy of the earth gives: 
$$\frac{1}{2}v_{esc}^2=\frac{GM_{\odot}}{r}$$
Solving:
\begin{equation}
v_{esc}=\sqrt{\frac{2GM_{\odot}}{r}}
\end{equation}
Which is the escape velocity of the earth, if we ignore the other planets. Note that this velocity is to be taken \textit{relative to the sun}. We can experiment with the initial velocity of our planets, and check if the velocity at which a planet manages to escape equals this quantity. This gives us another way to check the consistency of our results.
\subsection{The perihelion precession of Mercury}\label{GR_section}
One of the tests for Einstein's theory of relativity is the perihelion precession of Mercury.  Over time, the perihelion (the point where Mercury is closest to the sun) changes. This was initially thought to be due to the gravitational attraction of other planets, but the effect was too large.It turns out that this effect is due to general relativity, which predicts that gravity warps spacetime. This boils down to modifying the gravitational force to:
\begin{equation}\label{eq:GR_equation}
\vec{F}_G=\frac{GM_{\odot}M_{\mathrm{Mercury}}}{r^3}\left[1+\frac{3l^2}{r^2c^2}\right]\vec{r}
\end{equation}
Where $l=|\vec{l}|$ is the absolute value of the angular momentum per mass of the body the force acts on, and $c$ is the speed of light. This assumes that all other effects, such as gravitational attraction from other planets, have been ignored. In this case, experimental data shows that the perihelion angle precesses $43''=0.2085\  \mathrm{mrad}$ per 100 earth years. We will investigate if this relativistic correction can correctly predict the precession, by comparing the motion of Mercury (removing all other planets) with Newtonian gravity and with the relativistic expression for gravity.
\section{Methods}
In this section we give an overview of the methods that we employed to solve the problems outlined in the previous sections. We discuss the models we have implemented, the numerical implementation of these models and the equations from the previous section and finally the implementation of initial conditions.
\subsection{Models}\label{models}
We will implement four different models, to test our simulations under multiple circumstances. 
\subsubsection{First model - The earth-sun system}\label{First_model}
We begin with a simplified model of our solar system, containing only the earth and the sun. We simulate this using both the Euler forward algorithm and the Velocity-Verlet algorithm, which enables us to compare these methods. 
\subsubsection{Second model - The three body problem}
We slightly expand our system by also including the most massive planet - Jupiter. We can then investigate how large the effect of Jupiter is on the orbit of the earth. We will also make this slightly more extreme, by increasing the mass of Jupiter by a factor $10$ and a factor $1000$. In the latter case, we will be approaching a binary star system, as the mass of Jupiter is about $1000$ times less than the mass of the sun. Thus we expect a fairly chaotic behavior, which will allow us to study the stability of our Verlet solver.
\subsubsection{Third model - Entire solar system}
We then include all eight planets in the solar system, as well as Pluto for historical reasons. We also include all interactions between the planets. We use the Velocity-Verlet method to solve this numerically, which gives us an opportunity to study the stability of the Verlet-method on larger scales.
\subsubsection{Final model - The mercury-sun system}
Finally, we model only mercury and the sun, to investigate the perihelion precessions of mercury described in section \ref{GR_section}. Here we use the Verlet-solver, and implement both the Newtonian and the relativistic expressions for the gravitational force.
\subsection{Some interesting features of our numeric scripts}
\subsubsection{Data flow}
To ease the flow of data, we implement a class structure to our code. We have three interacting classes:
\begin{enumerate}
\item Particle class - a class which stores all variables related to a single planet.
\item System class - A class which stores all and computes all species related to the entire system.
\item ODESolver class - A class which computes acceleration based on the algorithms detailed in section \ref{discretize_equations}
\end{enumerate}
Finally we also implement a tailored vector class, which implements some key features of vector algebra needed to solve the equations in section \ref{Newtonian_Gravity}, such as addition, multiplication, norms, inner products and the cross product.
\subsubsection{Retrieving the initial conditions}
As described in section \ref{implement_IC}, the initial positions and velocities of all planets can be retrieved from NASA's  \href{http://ssd.jpl.nasa.gov/horizons.cgi#top}{webpages}. It is possible to establish a telnet connection to these websites, and retrieve the data automatically. We took inspiration from\textbf{INSERT STACKEXCHANGE PAGE HERE} when implementing this.\\
\linebreak
\linebreak
With the class structure and the initial conditions in place, we can then simply initialize the solar system by a code akin to the one shown below:
\lstinputlisting{Pseudo_code_make_planets.py}
And then we can simply solve the differential equations by calling:
\lstinputlisting{Pseudo_code_solve_system.py}

\subsection{Checking the consistency of our results}
\subsubsection{Checking conservation of energy and angular momentum per unit mass}
We check conservation of energy for every 10$0^{th}$ timestep in all of the models described in section \ref{models}, except for the case with relativistic gravity. As our background in general relativity is relatively limited, we are unsure whether or not energy and angular momentum per mass are conserved in this case.\\
\linebreak
Because magnitudes of deviations are notoriously difficult to interpret, we will instead record and analyze the relative error at a time, $t$, defined as:
\begin{equation}
\epsilon_{rel}=\frac{E_{\mathrm{initial}}-E(t)}{E_{\mathrm{initial}}}
\end{equation}
Where $E$ is the energy. We employ the same expression to check conservation of angular momentum per unit mass.
\subsubsection{Checking escape velocity}
We experiment with the initial velocity of earth in the earth-sun system until we see that the orbit is no longer elliptic but becomes parabolic. We then compare this to the value calculated in section \ref{escape_vel_section}.
\subsection{Investigating the perihelion processions of mercury}
To find the perihelion processions of mercury, we must develop an algorithm which checks for a minimum of the distance between the sun and mercury. We do this by storing the absolute value of the position vector for three different timesteps, and subsequently check if the value in the middle of these three is lower than the two others. If this is the case, we save it as a perihelion passing, and compute the angle. This is illustrated in the pseudo-code below:
\lstinputlisting{Pseudo_code_perihelion.py}

\section{Results}
\subsection{Results from the first model - Earth-Sun}
\subsubsection{Position}
\paragraph{The Euler-Forward algorithm}
\section{Discussion}
\subsection{Discussing the perihelion precession of mercury}
One interesting aspect of our investigation of the precession of mercury is that it broke down when we computed the angular momentum at every time step. When we used the initial angular momentum of mercury, however, (given by $\vec{l}=\vec{r}\times \vec{v}$) we got the correct result. \textbf{WHY}
\section{Conclusion and outlook}
\subsection{Conclusion}
\subsection{Outlook}
\begin{appendices}
\section{Initial velocity for circular orbits and the value of G}\label{ap:Find_Circular_orbit}
If we assume a two-body system, consisting of the earth and the sun, transform to a system where the sun's velocity is zero, and assume circular orbit, we can equate the force of gravity to the centripetal force. For the earth this gives:
$$\frac{GM_{\odot}m_e}{r^2}=m_e\frac{v_{circ}^2}{r}$$
Where $m_e$ is the mass of earth. Rearranging gives:
\begin{equation}\label{eq:Vel_for_cicrular_orbit}
v_{circ}=\sqrt{\frac{GM_{\odot}}{r}}
\end{equation}
Inserting $r=1 \mathrm{AU}$ gives for the earth $v_{circ}=29\ 780 \ \mathrm{m/s}=6.279 \ \mathrm{AU/yr}$. This is the velocity we must give the earth (in a frame where the initial velocity of the sun is zero), to ensure that it orbits in a circular orbit of radius $1 \mathrm{AU}$.\\
\linebreak
From this equation, we can also find a value for $G$ in the units astronomical units per year. We simply say that the earth takes one year to complete one revolution, which gives $v_{circ}=2\pi r/T=2\pi \ \mathrm{AU/yr}$. Solving equation \ref{eq:Vel_for_cicrular_orbit} for $G$ gives:
$$G=\frac{v_{circ}^2 r}{M_{\odot}}$$
Seeing as  $r=1 \ \mathrm{AU}$, this gives:
$$G=4\pi^2\ \ \mathrm{AU^3}\mathrm{yr^{-2}M_{\odot}^{-1}}$$
\section{Deriving the Velocity-Verlet algorithm}\label{ap:Deriving_VelVer}
Here will derive the Velocity-Verlet method. We will derive this for a single dimension ($x$), however the three-dimensional generalization is straightforward, as it simply amounts to repeating the exact same equation with $x$ exchanged with $y$ and $z$ respectively.\\
\linebreak
The Velocity-Verlet method is based on Taylor-expanding the acceleration, $a$, around $x=x_0$. This gives:
$$a(x_0+h)=a(x_0)+ha'(x_0)+O(h^2)$$
Or, discretizing as described in section \ref{discretize_equations}, gives approximately:
$$a_{i+1}\approx a_i+ha'_i$$
Or, rearranging slightly:
\begin{equation} \label{eq:discretized_acceleration}
ha_i'\approx a_{i+1}-a_i
\end{equation}
Now we expand the velocity in the same way, but include another term in the Taylor expansion. This gives:
$$v_{i+1}= v_i+ha_i+\frac{h^2}{2}a'_i+O(h^3)$$
Inserting from equation \ref{eq:discretized_acceleration} gives:
$$v_{i+1}=v_i+a_ih+\frac{h}{2}\left(a_{i+1}+a_i\right)+O(h^3)$$
Finally, we Taylor expand the position in the same way to get:
$$x_{i+1}=x_i+hv_i+\frac{h^2}{2}a_i+O(h^3)$$
These are the equations of the Velocity-Verlet algorithm described in equation \ref{eq:Vel_Ver_eq}. Notice how the error is proportional to $h^3$, as opposed to the Forward-Euler algorithm, where the error is proportional to $h^2$.

\end{appendices}

\end{document}

